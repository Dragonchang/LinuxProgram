
MessageQueue.o：     文件格式 elf64-x86-64
MessageQueue.o
体系结构：i386:x86-64， 标志 0x00000011：
HAS_RELOC, HAS_SYMS
起始地址 0x0000000000000000

节：
Idx Name          Size      VMA               LMA               File off  Algn
  0 .group        00000008  0000000000000000  0000000000000000  00000040  2**2
                  CONTENTS, READONLY, EXCLUDE, GROUP, LINK_ONCE_DISCARD
  1 .group        00000008  0000000000000000  0000000000000000  00000048  2**2
                  CONTENTS, READONLY, EXCLUDE, GROUP, LINK_ONCE_DISCARD
  2 .group        00000008  0000000000000000  0000000000000000  00000050  2**2
                  CONTENTS, READONLY, EXCLUDE, GROUP, LINK_ONCE_DISCARD
  3 .group        00000008  0000000000000000  0000000000000000  00000058  2**2
                  CONTENTS, READONLY, EXCLUDE, GROUP, LINK_ONCE_DISCARD
  4 .text         00000999  0000000000000000  0000000000000000  00000060  2**1
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  5 .data         00000000  0000000000000000  0000000000000000  000009f9  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00000000  0000000000000000  0000000000000000  000009f9  2**0
                  ALLOC
  7 .text._ZN7MessageC2Ev 0000002d  0000000000000000  0000000000000000  000009fa  2**1
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .rodata       00000510  0000000000000000  0000000000000000  00000a28  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .rodata._ZTV12MessageQueue 00000020  0000000000000000  0000000000000000  00000f40  2**5
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 10 .rodata._ZTI12MessageQueue 00000010  0000000000000000  0000000000000000  00000f60  2**4
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
 11 .rodata._ZTS12MessageQueue 0000000f  0000000000000000  0000000000000000  00000f70  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 12 .debug_info   00000ef0  0000000000000000  0000000000000000  00000f7f  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 13 .debug_abbrev 0000029c  0000000000000000  0000000000000000  00001e6f  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 00000040  0000000000000000  0000000000000000  0000210b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 15 .debug_ranges 00000060  0000000000000000  0000000000000000  0000214b  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 16 .debug_line   0000024b  0000000000000000  0000000000000000  000021ab  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
 17 .debug_str    000014e6  0000000000000000  0000000000000000  000023f6  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .comment      0000002c  0000000000000000  0000000000000000  000038dc  2**0
                  CONTENTS, READONLY
 19 .note.GNU-stack 00000000  0000000000000000  0000000000000000  00003908  2**0
                  CONTENTS, READONLY
 20 .eh_frame     000001c0  0000000000000000  0000000000000000  00003908  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
SYMBOL TABLE:
0000000000000000 l    df *ABS*	0000000000000000 MessageQueue.cpp
0000000000000000 l    d  .text	0000000000000000 .text
0000000000000000 l    d  .data	0000000000000000 .data
0000000000000000 l    d  .bss	0000000000000000 .bss
0000000000000000 l    d  .text._ZN7MessageC2Ev	0000000000000000 .text._ZN7MessageC2Ev
0000000000000000 l    d  .rodata	0000000000000000 .rodata
0000000000000000 l    d  .rodata._ZTV12MessageQueue	0000000000000000 .rodata._ZTV12MessageQueue
0000000000000000 l    d  .rodata._ZTI12MessageQueue	0000000000000000 .rodata._ZTI12MessageQueue
0000000000000000 l    d  .rodata._ZTS12MessageQueue	0000000000000000 .rodata._ZTS12MessageQueue
0000000000000508 l     O .rodata	0000000000000004 _ZL15EPOLL_SIZE_HINT
000000000000050c l     O .rodata	0000000000000004 _ZL16EPOLL_MAX_EVENTS
0000000000000000 l    d  .debug_info	0000000000000000 .debug_info
0000000000000000 l    d  .debug_abbrev	0000000000000000 .debug_abbrev
0000000000000000 l    d  .debug_aranges	0000000000000000 .debug_aranges
0000000000000000 l    d  .debug_ranges	0000000000000000 .debug_ranges
0000000000000000 l    d  .debug_line	0000000000000000 .debug_line
0000000000000000 l    d  .debug_str	0000000000000000 .debug_str
0000000000000000 l    d  .note.GNU-stack	0000000000000000 .note.GNU-stack
0000000000000000 l    d  .eh_frame	0000000000000000 .eh_frame
0000000000000000 l       .group	0000000000000000 _ZN7MessageC5Ev
0000000000000000 l    d  .comment	0000000000000000 .comment
0000000000000000 l    d  .group	0000000000000000 .group
0000000000000000 l    d  .group	0000000000000000 .group
0000000000000000 l    d  .group	0000000000000000 .group
0000000000000000 l    d  .group	0000000000000000 .group
0000000000000000  w    F .text._ZN7MessageC2Ev	000000000000002d _ZN7MessageC2Ev
0000000000000000         *UND*	0000000000000000 _ZTV7Message
0000000000000000  w    F .text._ZN7MessageC2Ev	000000000000002d _ZN7MessageC1Ev
0000000000000000 g     F .text	0000000000000099 _ZN12MessageQueueC2Ev
0000000000000000  w    O .rodata._ZTV12MessageQueue	0000000000000020 _ZTV12MessageQueue
0000000000000000         *UND*	0000000000000000 _Znwm
0000000000000000         *UND*	0000000000000000 pthread_mutex_init
000000000000009a g     F .text	000000000000017b _ZN12MessageQueue16buildEpollLockedEv
0000000000000000 g     F .text	0000000000000099 _ZN12MessageQueueC1Ev
0000000000000000         *UND*	0000000000000000 close
0000000000000000         *UND*	0000000000000000 pipe
0000000000000000         *UND*	0000000000000000 pthread_self
0000000000000000         *UND*	0000000000000000 printf
0000000000000000         *UND*	0000000000000000 fcntl
0000000000000000         *UND*	0000000000000000 epoll_create
0000000000000000         *UND*	0000000000000000 memset
0000000000000000         *UND*	0000000000000000 epoll_ctl
0000000000000216 g     F .text	0000000000000109 _ZN12MessageQueueD2Ev
00000000000003b6 g     F .text	0000000000000101 _ZN12MessageQueue16removeAllMessageEv
0000000000000000         *UND*	0000000000000000 pthread_mutex_destroy
0000000000000000         *UND*	0000000000000000 _ZdlPv
0000000000000216 g     F .text	0000000000000109 _ZN12MessageQueueD1Ev
0000000000000320 g     F .text	0000000000000026 _ZN12MessageQueueD0Ev
0000000000000346 g     F .text	0000000000000070 _ZN12MessageQueue12queueAtFrontEP7Message
0000000000000000         *UND*	0000000000000000 pthread_mutex_lock
0000000000000000         *UND*	0000000000000000 pthread_mutex_unlock
00000000000004b8 g     F .text	0000000000000193 _ZN12MessageQueue12removeAtTailEv
000000000000064c g     F .text	0000000000000218 _ZN12MessageQueue8pollOnceEi
0000000000000000         *UND*	0000000000000000 epoll_wait
0000000000000000         *UND*	0000000000000000 __errno_location
0000000000000864 g     F .text	000000000000004a _ZN12MessageQueue6awokenEv
0000000000000000         *UND*	0000000000000000 read
00000000000008ae g     F .text	0000000000000074 _ZN12MessageQueue4wakeEv
0000000000000000         *UND*	0000000000000000 write
0000000000000922 g     F .text	000000000000004b _ZN12MessageQueue14enqueueMessageEP7Message
000000000000096e g     F .text	000000000000002b _ZN12MessageQueue14getNextMessageEv
0000000000000000  w    O .rodata._ZTI12MessageQueue	0000000000000010 _ZTI12MessageQueue
0000000000000000         *UND*	0000000000000000 _ZTVN10__cxxabiv117__class_type_infoE
0000000000000000  w    O .rodata._ZTS12MessageQueue	000000000000000f _ZTS12MessageQueue



Disassembly of section .text:

0000000000000000 <_ZN12MessageQueueC1Ev>:
#include"MessageQueue.h"
static const int EPOLL_SIZE_HINT = 1024;
// Maximum number of file descriptors for which to retrieve poll events each iteration.
static const int EPOLL_MAX_EVENTS = 16;
MessageQueue::MessageQueue():mEpollFd(-1) {
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	53                   	push   %rbx
   5:	48 83 ec 18          	sub    $0x18,%rsp
   9:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
   d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  11:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			14: R_X86_64_32S	_ZTV12MessageQueue+0x10
  18:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  1c:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%rax)
    mHead = new Message();
  23:	bf 20 00 00 00       	mov    $0x20,%edi
  28:	e8 00 00 00 00       	callq  2d <_ZN12MessageQueueC1Ev+0x2d>
			29: R_X86_64_PC32	_Znwm-0x4
  2d:	48 89 c3             	mov    %rax,%rbx
  30:	48 89 df             	mov    %rbx,%rdi
  33:	e8 00 00 00 00       	callq  38 <_ZN12MessageQueueC1Ev+0x38>
			34: R_X86_64_PC32	_ZN7MessageC1Ev-0x4
  38:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  3c:	48 89 58 08          	mov    %rbx,0x8(%rax)
    mTail = new Message();
  40:	bf 20 00 00 00       	mov    $0x20,%edi
  45:	e8 00 00 00 00       	callq  4a <_ZN12MessageQueueC1Ev+0x4a>
			46: R_X86_64_PC32	_Znwm-0x4
  4a:	48 89 c3             	mov    %rax,%rbx
  4d:	48 89 df             	mov    %rbx,%rdi
  50:	e8 00 00 00 00       	callq  55 <_ZN12MessageQueueC1Ev+0x55>
			51: R_X86_64_PC32	_ZN7MessageC1Ev-0x4
  55:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  59:	48 89 58 10          	mov    %rbx,0x10(%rax)
    mHead->mNext = mTail;
  5d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  61:	48 8b 40 08          	mov    0x8(%rax),%rax
  65:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
  69:	48 8b 52 10          	mov    0x10(%rdx),%rdx
  6d:	48 89 50 18          	mov    %rdx,0x18(%rax)
    pthread_mutex_init(&mMutex, NULL);
  71:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  75:	48 83 c0 28          	add    $0x28,%rax
  79:	be 00 00 00 00       	mov    $0x0,%esi
  7e:	48 89 c7             	mov    %rax,%rdi
  81:	e8 00 00 00 00       	callq  86 <_ZN12MessageQueueC1Ev+0x86>
			82: R_X86_64_PC32	pthread_mutex_init-0x4
    buildEpollLocked();
  86:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
  8a:	48 89 c7             	mov    %rax,%rdi
  8d:	e8 00 00 00 00       	callq  92 <_ZN12MessageQueueC1Ev+0x92>
			8e: R_X86_64_PC32	_ZN12MessageQueue16buildEpollLockedEv-0x4
}
  92:	48 83 c4 18          	add    $0x18,%rsp
  96:	5b                   	pop    %rbx
  97:	5d                   	pop    %rbp
  98:	c3                   	retq   
  99:	90                   	nop

000000000000009a <_ZN12MessageQueue16buildEpollLockedEv>:

void MessageQueue::buildEpollLocked() {
  9a:	55                   	push   %rbp
  9b:	48 89 e5             	mov    %rsp,%rbp
  9e:	48 83 ec 40          	sub    $0x40,%rsp
  a2:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
    if (mEpollFd >= 0) {
  a6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  aa:	8b 40 20             	mov    0x20(%rax),%eax
  ad:	85 c0                	test   %eax,%eax
  af:	78 0e                	js     bf <_ZN12MessageQueue16buildEpollLockedEv+0x25>
        close(mEpollFd);
  b1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  b5:	8b 40 20             	mov    0x20(%rax),%eax
  b8:	89 c7                	mov    %eax,%edi
  ba:	e8 00 00 00 00       	callq  bf <_ZN12MessageQueue16buildEpollLockedEv+0x25>
			bb: R_X86_64_PC32	close-0x4
    }
    int result = 0;
  bf:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)

#ifdef USE_PIPE
    int wakeFds[2];
    result= pipe(wakeFds);
  c6:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
  ca:	48 89 c7             	mov    %rax,%rdi
  cd:	e8 00 00 00 00       	callq  d2 <_ZN12MessageQueue16buildEpollLockedEv+0x38>
			ce: R_X86_64_PC32	pipe-0x4
  d2:	89 45 dc             	mov    %eax,-0x24(%rbp)
    if(result !=0) {
  d5:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
  d9:	74 16                	je     f1 <_ZN12MessageQueue16buildEpollLockedEv+0x57>
        printf("tid:%d MessageQueue::buildEpollLocked pipe failed\n",(unsigned)pthread_self());
  db:	e8 00 00 00 00       	callq  e0 <_ZN12MessageQueue16buildEpollLockedEv+0x46>
			dc: R_X86_64_PC32	pthread_self-0x4
  e0:	89 c6                	mov    %eax,%esi
  e2:	bf 00 00 00 00       	mov    $0x0,%edi
			e3: R_X86_64_32	.rodata
  e7:	b8 00 00 00 00       	mov    $0x0,%eax
  ec:	e8 00 00 00 00       	callq  f1 <_ZN12MessageQueue16buildEpollLockedEv+0x57>
			ed: R_X86_64_PC32	printf-0x4
    }  
    mWakeReadPipeFd = wakeFds[0];
  f1:	8b 55 e0             	mov    -0x20(%rbp),%edx
  f4:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
  f8:	89 50 18             	mov    %edx,0x18(%rax)
    mWakeWritePipeFd = wakeFds[1];
  fb:	8b 55 e4             	mov    -0x1c(%rbp),%edx
  fe:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 102:	89 50 1c             	mov    %edx,0x1c(%rax)
    result = fcntl(mWakeReadPipeFd, F_SETFL, O_NONBLOCK);
 105:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 109:	8b 40 18             	mov    0x18(%rax),%eax
 10c:	ba 00 08 00 00       	mov    $0x800,%edx
 111:	be 04 00 00 00       	mov    $0x4,%esi
 116:	89 c7                	mov    %eax,%edi
 118:	b8 00 00 00 00       	mov    $0x0,%eax
 11d:	e8 00 00 00 00       	callq  122 <_ZN12MessageQueue16buildEpollLockedEv+0x88>
			11e: R_X86_64_PC32	fcntl-0x4
 122:	89 45 dc             	mov    %eax,-0x24(%rbp)
    if(result !=0) {
 125:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
 129:	74 16                	je     141 <_ZN12MessageQueue16buildEpollLockedEv+0xa7>
        printf("tid:%d MessageQueue::buildEpollLocked fcntl mWakeReadPipeFd failed\n",(unsigned)pthread_self());
 12b:	e8 00 00 00 00       	callq  130 <_ZN12MessageQueue16buildEpollLockedEv+0x96>
			12c: R_X86_64_PC32	pthread_self-0x4
 130:	89 c6                	mov    %eax,%esi
 132:	bf 00 00 00 00       	mov    $0x0,%edi
			133: R_X86_64_32	.rodata+0x38
 137:	b8 00 00 00 00       	mov    $0x0,%eax
 13c:	e8 00 00 00 00       	callq  141 <_ZN12MessageQueue16buildEpollLockedEv+0xa7>
			13d: R_X86_64_PC32	printf-0x4
    }  
    result = fcntl(mWakeWritePipeFd, F_SETFL, O_NONBLOCK);
 141:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 145:	8b 40 1c             	mov    0x1c(%rax),%eax
 148:	ba 00 08 00 00       	mov    $0x800,%edx
 14d:	be 04 00 00 00       	mov    $0x4,%esi
 152:	89 c7                	mov    %eax,%edi
 154:	b8 00 00 00 00       	mov    $0x0,%eax
 159:	e8 00 00 00 00       	callq  15e <_ZN12MessageQueue16buildEpollLockedEv+0xc4>
			15a: R_X86_64_PC32	fcntl-0x4
 15e:	89 45 dc             	mov    %eax,-0x24(%rbp)
    if(result !=0) {
 161:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
 165:	74 16                	je     17d <_ZN12MessageQueue16buildEpollLockedEv+0xe3>
        printf("tid:%d MessageQueue::buildEpollLocked fcntl mWakeWritePipeFd failed\n",(unsigned)pthread_self());
 167:	e8 00 00 00 00       	callq  16c <_ZN12MessageQueue16buildEpollLockedEv+0xd2>
			168: R_X86_64_PC32	pthread_self-0x4
 16c:	89 c6                	mov    %eax,%esi
 16e:	bf 00 00 00 00       	mov    $0x0,%edi
			16f: R_X86_64_32	.rodata+0x80
 173:	b8 00 00 00 00       	mov    $0x0,%eax
 178:	e8 00 00 00 00       	callq  17d <_ZN12MessageQueue16buildEpollLockedEv+0xe3>
			179: R_X86_64_PC32	printf-0x4
    if(mWakeEventFd <0) {
        printf("tid:%d MessageQueue::buildEpollLocked eventfd failed\n",(unsigned)pthread_self());
    }
#endif
    // Allocate the new epoll instance and register the wake pipe.
    mEpollFd = epoll_create(EPOLL_SIZE_HINT);
 17d:	bf 00 04 00 00       	mov    $0x400,%edi
 182:	e8 00 00 00 00       	callq  187 <_ZN12MessageQueue16buildEpollLockedEv+0xed>
			183: R_X86_64_PC32	epoll_create-0x4
 187:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
 18b:	89 42 20             	mov    %eax,0x20(%rdx)
    if(mEpollFd < 0) {
 18e:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 192:	8b 40 20             	mov    0x20(%rax),%eax
 195:	85 c0                	test   %eax,%eax
 197:	79 16                	jns    1af <_ZN12MessageQueue16buildEpollLockedEv+0x115>
        printf("tid:%d MessageQueue::buildEpollLocked epoll_create failed\n",(unsigned)pthread_self());
 199:	e8 00 00 00 00       	callq  19e <_ZN12MessageQueue16buildEpollLockedEv+0x104>
			19a: R_X86_64_PC32	pthread_self-0x4
 19e:	89 c6                	mov    %eax,%esi
 1a0:	bf 00 00 00 00       	mov    $0x0,%edi
			1a1: R_X86_64_32	.rodata+0xc8
 1a5:	b8 00 00 00 00       	mov    $0x0,%eax
 1aa:	e8 00 00 00 00       	callq  1af <_ZN12MessageQueue16buildEpollLockedEv+0x115>
			1ab: R_X86_64_PC32	printf-0x4
    }
    struct epoll_event eventItem;
    memset(& eventItem, 0, sizeof(epoll_event)); // zero out unused members of data field union
 1af:	48 8d 45 f0          	lea    -0x10(%rbp),%rax
 1b3:	ba 0c 00 00 00       	mov    $0xc,%edx
 1b8:	be 00 00 00 00       	mov    $0x0,%esi
 1bd:	48 89 c7             	mov    %rax,%rdi
 1c0:	e8 00 00 00 00       	callq  1c5 <_ZN12MessageQueue16buildEpollLockedEv+0x12b>
			1c1: R_X86_64_PC32	memset-0x4
    eventItem.events = EPOLLIN;
 1c5:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%rbp)

#ifdef USE_PIPE
    eventItem.data.fd = mWakeReadPipeFd;
 1cc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 1d0:	8b 40 18             	mov    0x18(%rax),%eax
 1d3:	89 45 f4             	mov    %eax,-0xc(%rbp)
    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeReadPipeFd, & eventItem);
 1d6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 1da:	8b 50 18             	mov    0x18(%rax),%edx
 1dd:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
 1e1:	8b 40 20             	mov    0x20(%rax),%eax
 1e4:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
 1e8:	be 01 00 00 00       	mov    $0x1,%esi
 1ed:	89 c7                	mov    %eax,%edi
 1ef:	e8 00 00 00 00       	callq  1f4 <_ZN12MessageQueue16buildEpollLockedEv+0x15a>
			1f0: R_X86_64_PC32	epoll_ctl-0x4
 1f4:	89 45 dc             	mov    %eax,-0x24(%rbp)
#else
    eventItem.data.fd = mWakeEventFd;
    result = epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, & eventItem);
#endif

    if(result != 0) {
 1f7:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
 1fb:	74 16                	je     213 <_ZN12MessageQueue16buildEpollLockedEv+0x179>
        printf("tid:%d MessageQueue::buildEpollLocked epoll_ctl add failed\n",(unsigned)pthread_self());
 1fd:	e8 00 00 00 00       	callq  202 <_ZN12MessageQueue16buildEpollLockedEv+0x168>
			1fe: R_X86_64_PC32	pthread_self-0x4
 202:	89 c6                	mov    %eax,%esi
 204:	bf 00 00 00 00       	mov    $0x0,%edi
			205: R_X86_64_32	.rodata+0x108
 209:	b8 00 00 00 00       	mov    $0x0,%eax
 20e:	e8 00 00 00 00       	callq  213 <_ZN12MessageQueue16buildEpollLockedEv+0x179>
			20f: R_X86_64_PC32	printf-0x4
    }
}
 213:	c9                   	leaveq 
 214:	c3                   	retq   
 215:	90                   	nop

0000000000000216 <_ZN12MessageQueueD1Ev>:

MessageQueue::~MessageQueue() {
 216:	55                   	push   %rbp
 217:	48 89 e5             	mov    %rsp,%rbp
 21a:	48 83 ec 10          	sub    $0x10,%rsp
 21e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 222:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 226:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			229: R_X86_64_32S	_ZTV12MessageQueue+0x10
   removeAllMessage();
 22d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 231:	48 89 c7             	mov    %rax,%rdi
 234:	e8 00 00 00 00       	callq  239 <_ZN12MessageQueueD1Ev+0x23>
			235: R_X86_64_PC32	_ZN12MessageQueue16removeAllMessageEv-0x4
   if (mHead != NULL) {
 239:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 23d:	48 8b 40 08          	mov    0x8(%rax),%rax
 241:	48 85 c0             	test   %rax,%rax
 244:	74 38                	je     27e <_ZN12MessageQueueD1Ev+0x68>
      delete mHead;
 246:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 24a:	48 8b 40 08          	mov    0x8(%rax),%rax
 24e:	48 85 c0             	test   %rax,%rax
 251:	74 1f                	je     272 <_ZN12MessageQueueD1Ev+0x5c>
 253:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 257:	48 8b 40 08          	mov    0x8(%rax),%rax
 25b:	48 8b 00             	mov    (%rax),%rax
 25e:	48 83 c0 08          	add    $0x8,%rax
 262:	48 8b 00             	mov    (%rax),%rax
 265:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 269:	48 8b 52 08          	mov    0x8(%rdx),%rdx
 26d:	48 89 d7             	mov    %rdx,%rdi
 270:	ff d0                	callq  *%rax
      mHead = NULL;
 272:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 276:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
 27d:	00 
   }
   if (mTail != NULL) {
 27e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 282:	48 8b 40 10          	mov    0x10(%rax),%rax
 286:	48 85 c0             	test   %rax,%rax
 289:	74 38                	je     2c3 <_ZN12MessageQueueD1Ev+0xad>
      delete mTail;
 28b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 28f:	48 8b 40 10          	mov    0x10(%rax),%rax
 293:	48 85 c0             	test   %rax,%rax
 296:	74 1f                	je     2b7 <_ZN12MessageQueueD1Ev+0xa1>
 298:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 29c:	48 8b 40 10          	mov    0x10(%rax),%rax
 2a0:	48 8b 00             	mov    (%rax),%rax
 2a3:	48 83 c0 08          	add    $0x8,%rax
 2a7:	48 8b 00             	mov    (%rax),%rax
 2aa:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 2ae:	48 8b 52 10          	mov    0x10(%rdx),%rdx
 2b2:	48 89 d7             	mov    %rdx,%rdi
 2b5:	ff d0                	callq  *%rax
      mTail = NULL;
 2b7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 2bb:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
 2c2:	00 
   }
#ifdef USE_PIPE
    close(mWakeReadPipeFd);
 2c3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 2c7:	8b 40 18             	mov    0x18(%rax),%eax
 2ca:	89 c7                	mov    %eax,%edi
 2cc:	e8 00 00 00 00       	callq  2d1 <_ZN12MessageQueueD1Ev+0xbb>
			2cd: R_X86_64_PC32	close-0x4
    close(mWakeWritePipeFd);
 2d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 2d5:	8b 40 1c             	mov    0x1c(%rax),%eax
 2d8:	89 c7                	mov    %eax,%edi
 2da:	e8 00 00 00 00       	callq  2df <_ZN12MessageQueueD1Ev+0xc9>
			2db: R_X86_64_PC32	close-0x4
#else
    close(mWakeEventFd);
#endif
    if (mEpollFd >= 0) {
 2df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 2e3:	8b 40 20             	mov    0x20(%rax),%eax
 2e6:	85 c0                	test   %eax,%eax
 2e8:	78 0e                	js     2f8 <_ZN12MessageQueueD1Ev+0xe2>
        close(mEpollFd);
 2ea:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 2ee:	8b 40 20             	mov    0x20(%rax),%eax
 2f1:	89 c7                	mov    %eax,%edi
 2f3:	e8 00 00 00 00       	callq  2f8 <_ZN12MessageQueueD1Ev+0xe2>
			2f4: R_X86_64_PC32	close-0x4
    }
    pthread_mutex_destroy(&mMutex);
 2f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 2fc:	48 83 c0 28          	add    $0x28,%rax
 300:	48 89 c7             	mov    %rax,%rdi
 303:	e8 00 00 00 00       	callq  308 <_ZN12MessageQueueD1Ev+0xf2>
			304: R_X86_64_PC32	pthread_mutex_destroy-0x4
}
 308:	b8 00 00 00 00       	mov    $0x0,%eax
 30d:	85 c0                	test   %eax,%eax
 30f:	74 0c                	je     31d <_ZN12MessageQueueD1Ev+0x107>
 311:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 315:	48 89 c7             	mov    %rax,%rdi
 318:	e8 00 00 00 00       	callq  31d <_ZN12MessageQueueD1Ev+0x107>
			319: R_X86_64_PC32	_ZdlPv-0x4
 31d:	c9                   	leaveq 
 31e:	c3                   	retq   
 31f:	90                   	nop

0000000000000320 <_ZN12MessageQueueD0Ev>:
    if(result != 0) {
        printf("tid:%d MessageQueue::buildEpollLocked epoll_ctl add failed\n",(unsigned)pthread_self());
    }
}

MessageQueue::~MessageQueue() {
 320:	55                   	push   %rbp
 321:	48 89 e5             	mov    %rsp,%rbp
 324:	48 83 ec 10          	sub    $0x10,%rsp
 328:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
#endif
    if (mEpollFd >= 0) {
        close(mEpollFd);
    }
    pthread_mutex_destroy(&mMutex);
}
 32c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 330:	48 89 c7             	mov    %rax,%rdi
 333:	e8 00 00 00 00       	callq  338 <_ZN12MessageQueueD0Ev+0x18>
			334: R_X86_64_PC32	_ZN12MessageQueueD1Ev-0x4
 338:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 33c:	48 89 c7             	mov    %rax,%rdi
 33f:	e8 00 00 00 00       	callq  344 <_ZN12MessageQueueD0Ev+0x24>
			340: R_X86_64_PC32	_ZdlPv-0x4
 344:	c9                   	leaveq 
 345:	c3                   	retq   

0000000000000346 <_ZN12MessageQueue12queueAtFrontEP7Message>:

void MessageQueue::queueAtFront(Message* message) {
 346:	55                   	push   %rbp
 347:	48 89 e5             	mov    %rsp,%rbp
 34a:	48 83 ec 10          	sub    $0x10,%rsp
 34e:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 352:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    printf("tid:%d MessageQueue::queueAtFront message%p\n",(unsigned)pthread_self(), message);
 356:	e8 00 00 00 00       	callq  35b <_ZN12MessageQueue12queueAtFrontEP7Message+0x15>
			357: R_X86_64_PC32	pthread_self-0x4
 35b:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
 35f:	89 c6                	mov    %eax,%esi
 361:	bf 00 00 00 00       	mov    $0x0,%edi
			362: R_X86_64_32	.rodata+0x148
 366:	b8 00 00 00 00       	mov    $0x0,%eax
 36b:	e8 00 00 00 00       	callq  370 <_ZN12MessageQueue12queueAtFrontEP7Message+0x2a>
			36c: R_X86_64_PC32	printf-0x4
    pthread_mutex_lock(&mMutex);
 370:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 374:	48 83 c0 28          	add    $0x28,%rax
 378:	48 89 c7             	mov    %rax,%rdi
 37b:	e8 00 00 00 00       	callq  380 <_ZN12MessageQueue12queueAtFrontEP7Message+0x3a>
			37c: R_X86_64_PC32	pthread_mutex_lock-0x4
    message->mNext = mHead->mNext;
 380:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 384:	48 8b 40 08          	mov    0x8(%rax),%rax
 388:	48 8b 50 18          	mov    0x18(%rax),%rdx
 38c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 390:	48 89 50 18          	mov    %rdx,0x18(%rax)
    mHead->mNext = message;
 394:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 398:	48 8b 40 08          	mov    0x8(%rax),%rax
 39c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
 3a0:	48 89 50 18          	mov    %rdx,0x18(%rax)
    // Release lock.
    pthread_mutex_unlock(&mMutex);
 3a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 3a8:	48 83 c0 28          	add    $0x28,%rax
 3ac:	48 89 c7             	mov    %rax,%rdi
 3af:	e8 00 00 00 00       	callq  3b4 <_ZN12MessageQueue12queueAtFrontEP7Message+0x6e>
			3b0: R_X86_64_PC32	pthread_mutex_unlock-0x4
}
 3b4:	c9                   	leaveq 
 3b5:	c3                   	retq   

00000000000003b6 <_ZN12MessageQueue16removeAllMessageEv>:

void MessageQueue::removeAllMessage() {
 3b6:	55                   	push   %rbp
 3b7:	48 89 e5             	mov    %rsp,%rbp
 3ba:	48 83 ec 20          	sub    $0x20,%rsp
 3be:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
    pthread_mutex_lock(&mMutex);
 3c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 3c6:	48 83 c0 28          	add    $0x28,%rax
 3ca:	48 89 c7             	mov    %rax,%rdi
 3cd:	e8 00 00 00 00       	callq  3d2 <_ZN12MessageQueue16removeAllMessageEv+0x1c>
			3ce: R_X86_64_PC32	pthread_mutex_lock-0x4
    //TODO 需要遍历链表删除message
    Message* indexMessage;
    Message* removeMessage;
    if (mHead->mNext == mTail) {
 3d2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 3d6:	48 8b 40 08          	mov    0x8(%rax),%rax
 3da:	48 8b 50 18          	mov    0x18(%rax),%rdx
 3de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 3e2:	48 8b 40 10          	mov    0x10(%rax),%rax
 3e6:	48 39 c2             	cmp    %rax,%rdx
 3e9:	75 2b                	jne    416 <_ZN12MessageQueue16removeAllMessageEv+0x60>
        printf("tid:%d removeAllMessage:MessageQueue is empty!\n",(unsigned)pthread_self());
 3eb:	e8 00 00 00 00       	callq  3f0 <_ZN12MessageQueue16removeAllMessageEv+0x3a>
			3ec: R_X86_64_PC32	pthread_self-0x4
 3f0:	89 c6                	mov    %eax,%esi
 3f2:	bf 00 00 00 00       	mov    $0x0,%edi
			3f3: R_X86_64_32	.rodata+0x178
 3f7:	b8 00 00 00 00       	mov    $0x0,%eax
 3fc:	e8 00 00 00 00       	callq  401 <_ZN12MessageQueue16removeAllMessageEv+0x4b>
			3fd: R_X86_64_PC32	printf-0x4
        pthread_mutex_unlock(&mMutex);
 401:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 405:	48 83 c0 28          	add    $0x28,%rax
 409:	48 89 c7             	mov    %rax,%rdi
 40c:	e8 00 00 00 00       	callq  411 <_ZN12MessageQueue16removeAllMessageEv+0x5b>
			40d: R_X86_64_PC32	pthread_mutex_unlock-0x4
        return;
 411:	e9 9f 00 00 00       	jmpq   4b5 <_ZN12MessageQueue16removeAllMessageEv+0xff>
    }
    for(indexMessage = mHead->mNext; indexMessage != mTail;indexMessage = indexMessage->mNext) {
 416:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 41a:	48 8b 40 08          	mov    0x8(%rax),%rax
 41e:	48 8b 40 18          	mov    0x18(%rax),%rax
 422:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
 426:	eb 6f                	jmp    497 <_ZN12MessageQueue16removeAllMessageEv+0xe1>
        mHead->mNext = indexMessage->mNext;
 428:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 42c:	48 8b 40 08          	mov    0x8(%rax),%rax
 430:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 434:	48 8b 52 18          	mov    0x18(%rdx),%rdx
 438:	48 89 50 18          	mov    %rdx,0x18(%rax)
        delete indexMessage;
 43c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
 441:	74 17                	je     45a <_ZN12MessageQueue16removeAllMessageEv+0xa4>
 443:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 447:	48 8b 00             	mov    (%rax),%rax
 44a:	48 83 c0 08          	add    $0x8,%rax
 44e:	48 8b 00             	mov    (%rax),%rax
 451:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 455:	48 89 d7             	mov    %rdx,%rdi
 458:	ff d0                	callq  *%rax
        if (mHead->mNext == mTail) {
 45a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 45e:	48 8b 40 08          	mov    0x8(%rax),%rax
 462:	48 8b 50 18          	mov    0x18(%rax),%rdx
 466:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 46a:	48 8b 40 10          	mov    0x10(%rax),%rax
 46e:	48 39 c2             	cmp    %rax,%rdx
 471:	75 18                	jne    48b <_ZN12MessageQueue16removeAllMessageEv+0xd5>
            printf("tid:%d all message was deleted!\n",(unsigned)pthread_self());
 473:	e8 00 00 00 00       	callq  478 <_ZN12MessageQueue16removeAllMessageEv+0xc2>
			474: R_X86_64_PC32	pthread_self-0x4
 478:	89 c6                	mov    %eax,%esi
 47a:	bf 00 00 00 00       	mov    $0x0,%edi
			47b: R_X86_64_32	.rodata+0x1a8
 47f:	b8 00 00 00 00       	mov    $0x0,%eax
 484:	e8 00 00 00 00       	callq  489 <_ZN12MessageQueue16removeAllMessageEv+0xd3>
			485: R_X86_64_PC32	printf-0x4
            break;
 489:	eb 1a                	jmp    4a5 <_ZN12MessageQueue16removeAllMessageEv+0xef>
    if (mHead->mNext == mTail) {
        printf("tid:%d removeAllMessage:MessageQueue is empty!\n",(unsigned)pthread_self());
        pthread_mutex_unlock(&mMutex);
        return;
    }
    for(indexMessage = mHead->mNext; indexMessage != mTail;indexMessage = indexMessage->mNext) {
 48b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 48f:	48 8b 40 18          	mov    0x18(%rax),%rax
 493:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
 497:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 49b:	48 8b 40 10          	mov    0x10(%rax),%rax
 49f:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
 4a3:	75 83                	jne    428 <_ZN12MessageQueue16removeAllMessageEv+0x72>
        if (mHead->mNext == mTail) {
            printf("tid:%d all message was deleted!\n",(unsigned)pthread_self());
            break;
        }
    }
    pthread_mutex_unlock(&mMutex);
 4a5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 4a9:	48 83 c0 28          	add    $0x28,%rax
 4ad:	48 89 c7             	mov    %rax,%rdi
 4b0:	e8 00 00 00 00       	callq  4b5 <_ZN12MessageQueue16removeAllMessageEv+0xff>
			4b1: R_X86_64_PC32	pthread_mutex_unlock-0x4
}
 4b5:	c9                   	leaveq 
 4b6:	c3                   	retq   
 4b7:	90                   	nop

00000000000004b8 <_ZN12MessageQueue12removeAtTailEv>:

Message* MessageQueue::removeAtTail() {
 4b8:	55                   	push   %rbp
 4b9:	48 89 e5             	mov    %rsp,%rbp
 4bc:	48 83 ec 30          	sub    $0x30,%rsp
 4c0:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
    printf("tid:%d MessageQueue::removeAtTail***begin! \n",(unsigned)pthread_self());
 4c4:	e8 00 00 00 00       	callq  4c9 <_ZN12MessageQueue12removeAtTailEv+0x11>
			4c5: R_X86_64_PC32	pthread_self-0x4
 4c9:	89 c6                	mov    %eax,%esi
 4cb:	bf 00 00 00 00       	mov    $0x0,%edi
			4cc: R_X86_64_32	.rodata+0x1d0
 4d0:	b8 00 00 00 00       	mov    $0x0,%eax
 4d5:	e8 00 00 00 00       	callq  4da <_ZN12MessageQueue12removeAtTailEv+0x22>
			4d6: R_X86_64_PC32	printf-0x4
    // Acquire lock.
    pthread_mutex_lock(&mMutex);
 4da:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 4de:	48 83 c0 28          	add    $0x28,%rax
 4e2:	48 89 c7             	mov    %rax,%rdi
 4e5:	e8 00 00 00 00       	callq  4ea <_ZN12MessageQueue12removeAtTailEv+0x32>
			4e6: R_X86_64_PC32	pthread_mutex_lock-0x4
    printf("tid:%d MessageQueue::removeAtTail***begin111111! \n",(unsigned)pthread_self());
 4ea:	e8 00 00 00 00       	callq  4ef <_ZN12MessageQueue12removeAtTailEv+0x37>
			4eb: R_X86_64_PC32	pthread_self-0x4
 4ef:	89 c6                	mov    %eax,%esi
 4f1:	bf 00 00 00 00       	mov    $0x0,%edi
			4f2: R_X86_64_32	.rodata+0x200
 4f6:	b8 00 00 00 00       	mov    $0x0,%eax
 4fb:	e8 00 00 00 00       	callq  500 <_ZN12MessageQueue12removeAtTailEv+0x48>
			4fc: R_X86_64_PC32	printf-0x4
    Message* indexMessage;
    Message* removeMessage;
    bool onlyOneMessage = false;
 500:	c6 45 ef 00          	movb   $0x0,-0x11(%rbp)
    if (mHead->mNext == mTail) {
 504:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 508:	48 8b 40 08          	mov    0x8(%rax),%rax
 50c:	48 8b 50 18          	mov    0x18(%rax),%rdx
 510:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 514:	48 8b 40 10          	mov    0x10(%rax),%rax
 518:	48 39 c2             	cmp    %rax,%rdx
 51b:	75 30                	jne    54d <_ZN12MessageQueue12removeAtTailEv+0x95>
        printf("tid:%d MessageQueue is empty!\n",(unsigned)pthread_self());
 51d:	e8 00 00 00 00       	callq  522 <_ZN12MessageQueue12removeAtTailEv+0x6a>
			51e: R_X86_64_PC32	pthread_self-0x4
 522:	89 c6                	mov    %eax,%esi
 524:	bf 00 00 00 00       	mov    $0x0,%edi
			525: R_X86_64_32	.rodata+0x238
 529:	b8 00 00 00 00       	mov    $0x0,%eax
 52e:	e8 00 00 00 00       	callq  533 <_ZN12MessageQueue12removeAtTailEv+0x7b>
			52f: R_X86_64_PC32	printf-0x4
        pthread_mutex_unlock(&mMutex);
 533:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 537:	48 83 c0 28          	add    $0x28,%rax
 53b:	48 89 c7             	mov    %rax,%rdi
 53e:	e8 00 00 00 00       	callq  543 <_ZN12MessageQueue12removeAtTailEv+0x8b>
			53f: R_X86_64_PC32	pthread_mutex_unlock-0x4
        return NULL;
 543:	b8 00 00 00 00       	mov    $0x0,%eax
 548:	e9 fc 00 00 00       	jmpq   649 <_ZN12MessageQueue12removeAtTailEv+0x191>
    }
    for(indexMessage = mHead->mNext; indexMessage != mTail;indexMessage = indexMessage->mNext) {
 54d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 551:	48 8b 40 08          	mov    0x8(%rax),%rax
 555:	48 8b 40 18          	mov    0x18(%rax),%rax
 559:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
 55d:	eb 6e                	jmp    5cd <_ZN12MessageQueue12removeAtTailEv+0x115>
       if (indexMessage->mNext == mTail) {
 55f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 563:	48 8b 50 18          	mov    0x18(%rax),%rdx
 567:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 56b:	48 8b 40 10          	mov    0x10(%rax),%rax
 56f:	48 39 c2             	cmp    %rax,%rdx
 572:	75 1c                	jne    590 <_ZN12MessageQueue12removeAtTailEv+0xd8>
           onlyOneMessage = true;
 574:	c6 45 ef 01          	movb   $0x1,-0x11(%rbp)
           printf("tid:%d only one message at MessageQueue\n",(unsigned)pthread_self());
 578:	e8 00 00 00 00       	callq  57d <_ZN12MessageQueue12removeAtTailEv+0xc5>
			579: R_X86_64_PC32	pthread_self-0x4
 57d:	89 c6                	mov    %eax,%esi
 57f:	bf 00 00 00 00       	mov    $0x0,%edi
			580: R_X86_64_32	.rodata+0x258
 584:	b8 00 00 00 00       	mov    $0x0,%eax
 589:	e8 00 00 00 00       	callq  58e <_ZN12MessageQueue12removeAtTailEv+0xd6>
			58a: R_X86_64_PC32	printf-0x4
           break;
 58e:	eb 4b                	jmp    5db <_ZN12MessageQueue12removeAtTailEv+0x123>
       }
       if(indexMessage->mNext->mNext == mTail) {
 590:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 594:	48 8b 40 18          	mov    0x18(%rax),%rax
 598:	48 8b 50 18          	mov    0x18(%rax),%rdx
 59c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 5a0:	48 8b 40 10          	mov    0x10(%rax),%rax
 5a4:	48 39 c2             	cmp    %rax,%rdx
 5a7:	75 18                	jne    5c1 <_ZN12MessageQueue12removeAtTailEv+0x109>
           printf("tid:%d find the last second message at MessageQueue\n",(unsigned)pthread_self());
 5a9:	e8 00 00 00 00       	callq  5ae <_ZN12MessageQueue12removeAtTailEv+0xf6>
			5aa: R_X86_64_PC32	pthread_self-0x4
 5ae:	89 c6                	mov    %eax,%esi
 5b0:	bf 00 00 00 00       	mov    $0x0,%edi
			5b1: R_X86_64_32	.rodata+0x288
 5b5:	b8 00 00 00 00       	mov    $0x0,%eax
 5ba:	e8 00 00 00 00       	callq  5bf <_ZN12MessageQueue12removeAtTailEv+0x107>
			5bb: R_X86_64_PC32	printf-0x4
           break;
 5bf:	eb 1a                	jmp    5db <_ZN12MessageQueue12removeAtTailEv+0x123>
    if (mHead->mNext == mTail) {
        printf("tid:%d MessageQueue is empty!\n",(unsigned)pthread_self());
        pthread_mutex_unlock(&mMutex);
        return NULL;
    }
    for(indexMessage = mHead->mNext; indexMessage != mTail;indexMessage = indexMessage->mNext) {
 5c1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 5c5:	48 8b 40 18          	mov    0x18(%rax),%rax
 5c9:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
 5cd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 5d1:	48 8b 40 10          	mov    0x10(%rax),%rax
 5d5:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
 5d9:	75 84                	jne    55f <_ZN12MessageQueue12removeAtTailEv+0xa7>
           printf("tid:%d find the last second message at MessageQueue\n",(unsigned)pthread_self());
           break;
       }
       //printf("tid:%d MessageQueue::removeAtTail***111111111! indexMessage%p\n",(unsigned)pthread_self(), indexMessage);
    }
    if (onlyOneMessage) {
 5db:	80 7d ef 00          	cmpb   $0x0,-0x11(%rbp)
 5df:	74 1e                	je     5ff <_ZN12MessageQueue12removeAtTailEv+0x147>
        removeMessage = indexMessage;
 5e1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 5e5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        mHead->mNext = mTail;
 5e9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 5ed:	48 8b 40 08          	mov    0x8(%rax),%rax
 5f1:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
 5f5:	48 8b 52 10          	mov    0x10(%rdx),%rdx
 5f9:	48 89 50 18          	mov    %rdx,0x18(%rax)
 5fd:	eb 1c                	jmp    61b <_ZN12MessageQueue12removeAtTailEv+0x163>
    } else {
        removeMessage = indexMessage->mNext;
 5ff:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 603:	48 8b 40 18          	mov    0x18(%rax),%rax
 607:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
        indexMessage->mNext = mTail;
 60b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 60f:	48 8b 50 10          	mov    0x10(%rax),%rdx
 613:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
 617:	48 89 50 18          	mov    %rdx,0x18(%rax)
    }
    // Release lock.
    pthread_mutex_unlock(&mMutex);
 61b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
 61f:	48 83 c0 28          	add    $0x28,%rax
 623:	48 89 c7             	mov    %rax,%rdi
 626:	e8 00 00 00 00       	callq  62b <_ZN12MessageQueue12removeAtTailEv+0x173>
			627: R_X86_64_PC32	pthread_mutex_unlock-0x4
    printf("tid:%d MessageQueue::removeAtTail ***end!! %p\n",(unsigned)pthread_self(),removeMessage);
 62b:	e8 00 00 00 00       	callq  630 <_ZN12MessageQueue12removeAtTailEv+0x178>
			62c: R_X86_64_PC32	pthread_self-0x4
 630:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 634:	89 c6                	mov    %eax,%esi
 636:	bf 00 00 00 00       	mov    $0x0,%edi
			637: R_X86_64_32	.rodata+0x2c0
 63b:	b8 00 00 00 00       	mov    $0x0,%eax
 640:	e8 00 00 00 00       	callq  645 <_ZN12MessageQueue12removeAtTailEv+0x18d>
			641: R_X86_64_PC32	printf-0x4
    return removeMessage;
 645:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
}
 649:	c9                   	leaveq 
 64a:	c3                   	retq   
 64b:	90                   	nop

000000000000064c <_ZN12MessageQueue8pollOnceEi>:

int MessageQueue::pollOnce(int timeoutMillis) {
 64c:	55                   	push   %rbp
 64d:	48 89 e5             	mov    %rsp,%rbp
 650:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
 657:	48 89 bd 18 ff ff ff 	mov    %rdi,-0xe8(%rbp)
 65e:	89 b5 14 ff ff ff    	mov    %esi,-0xec(%rbp)
    int result = 0;
 664:	c7 85 2c ff ff ff 00 	movl   $0x0,-0xd4(%rbp)
 66b:	00 00 00 
    for (;;) {
        printf("tid:%d MessageQueue::pollOnce result = %d.\n",(unsigned)pthread_self(), result);
 66e:	e8 00 00 00 00       	callq  673 <_ZN12MessageQueue8pollOnceEi+0x27>
			66f: R_X86_64_PC32	pthread_self-0x4
 673:	8b 95 2c ff ff ff    	mov    -0xd4(%rbp),%edx
 679:	89 c6                	mov    %eax,%esi
 67b:	bf 00 00 00 00       	mov    $0x0,%edi
			67c: R_X86_64_32	.rodata+0x2f0
 680:	b8 00 00 00 00       	mov    $0x0,%eax
 685:	e8 00 00 00 00       	callq  68a <_ZN12MessageQueue8pollOnceEi+0x3e>
			686: R_X86_64_PC32	printf-0x4
        if (result != 0) {
 68a:	83 bd 2c ff ff ff 00 	cmpl   $0x0,-0xd4(%rbp)
 691:	74 21                	je     6b4 <_ZN12MessageQueue8pollOnceEi+0x68>
            printf("tid:%d MessageQueue::pollOnce result != 0.\n",(unsigned)pthread_self());
 693:	e8 00 00 00 00       	callq  698 <_ZN12MessageQueue8pollOnceEi+0x4c>
			694: R_X86_64_PC32	pthread_self-0x4
 698:	89 c6                	mov    %eax,%esi
 69a:	bf 00 00 00 00       	mov    $0x0,%edi
			69b: R_X86_64_32	.rodata+0x320
 69f:	b8 00 00 00 00       	mov    $0x0,%eax
 6a4:	e8 00 00 00 00       	callq  6a9 <_ZN12MessageQueue8pollOnceEi+0x5d>
			6a5: R_X86_64_PC32	printf-0x4
                    printf("tid:%d Ignoring unexpected epoll events 0x%x on wake event fd.\n",(unsigned)pthread_self() ,epollEvents);
                }
            }
        }
    }
    return result;
 6a9:	8b 85 2c ff ff ff    	mov    -0xd4(%rbp),%eax
 6af:	e9 ae 01 00 00       	jmpq   862 <_ZN12MessageQueue8pollOnceEi+0x216>
        if (result != 0) {
            printf("tid:%d MessageQueue::pollOnce result != 0.\n",(unsigned)pthread_self());
            break;
        }
        struct epoll_event eventItems[EPOLL_MAX_EVENTS];
        result = -1;
 6b4:	c7 85 2c ff ff ff ff 	movl   $0xffffffff,-0xd4(%rbp)
 6bb:	ff ff ff 
        printf("tid:%d MessageQueue::pollOnce epoll_wait, begin\n", (unsigned)pthread_self());
 6be:	e8 00 00 00 00       	callq  6c3 <_ZN12MessageQueue8pollOnceEi+0x77>
			6bf: R_X86_64_PC32	pthread_self-0x4
 6c3:	89 c6                	mov    %eax,%esi
 6c5:	bf 00 00 00 00       	mov    $0x0,%edi
			6c6: R_X86_64_32	.rodata+0x350
 6ca:	b8 00 00 00 00       	mov    $0x0,%eax
 6cf:	e8 00 00 00 00       	callq  6d4 <_ZN12MessageQueue8pollOnceEi+0x88>
			6d0: R_X86_64_PC32	printf-0x4
        int eventCount = epoll_wait(mEpollFd, eventItems, EPOLL_MAX_EVENTS, timeoutMillis);
 6d4:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
 6db:	8b 40 20             	mov    0x20(%rax),%eax
 6de:	8b 95 14 ff ff ff    	mov    -0xec(%rbp),%edx
 6e4:	48 8d b5 40 ff ff ff 	lea    -0xc0(%rbp),%rsi
 6eb:	89 d1                	mov    %edx,%ecx
 6ed:	ba 10 00 00 00       	mov    $0x10,%edx
 6f2:	89 c7                	mov    %eax,%edi
 6f4:	e8 00 00 00 00       	callq  6f9 <_ZN12MessageQueue8pollOnceEi+0xad>
			6f5: R_X86_64_PC32	epoll_wait-0x4
 6f9:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%rbp)
        printf("tid:%d MessageQueue::pollOnce epoll_wait, end eventCount=%d\n", (unsigned)pthread_self() ,eventCount);
 6ff:	e8 00 00 00 00       	callq  704 <_ZN12MessageQueue8pollOnceEi+0xb8>
			700: R_X86_64_PC32	pthread_self-0x4
 704:	8b 95 34 ff ff ff    	mov    -0xcc(%rbp),%edx
 70a:	89 c6                	mov    %eax,%esi
 70c:	bf 00 00 00 00       	mov    $0x0,%edi
			70d: R_X86_64_32	.rodata+0x388
 711:	b8 00 00 00 00       	mov    $0x0,%eax
 716:	e8 00 00 00 00       	callq  71b <_ZN12MessageQueue8pollOnceEi+0xcf>
			717: R_X86_64_PC32	printf-0x4
        // Check for poll error.
        if (eventCount < 0) {
 71b:	83 bd 34 ff ff ff 00 	cmpl   $0x0,-0xcc(%rbp)
 722:	79 42                	jns    766 <_ZN12MessageQueue8pollOnceEi+0x11a>
	    if (errno == EINTR) {
 724:	e8 00 00 00 00       	callq  729 <_ZN12MessageQueue8pollOnceEi+0xdd>
			725: R_X86_64_PC32	__errno_location-0x4
 729:	8b 00                	mov    (%rax),%eax
 72b:	83 f8 04             	cmp    $0x4,%eax
 72e:	75 0b                	jne    73b <_ZN12MessageQueue8pollOnceEi+0xef>
	        return result;
 730:	8b 85 2c ff ff ff    	mov    -0xd4(%rbp),%eax
 736:	e9 27 01 00 00       	jmpq   862 <_ZN12MessageQueue8pollOnceEi+0x216>
	    }
            printf("tid:%d MessageQueue::pollOnce eventCount < 0.\n",(unsigned)pthread_self());
 73b:	e8 00 00 00 00       	callq  740 <_ZN12MessageQueue8pollOnceEi+0xf4>
			73c: R_X86_64_PC32	pthread_self-0x4
 740:	89 c6                	mov    %eax,%esi
 742:	bf 00 00 00 00       	mov    $0x0,%edi
			743: R_X86_64_32	.rodata+0x3c8
 747:	b8 00 00 00 00       	mov    $0x0,%eax
 74c:	e8 00 00 00 00       	callq  751 <_ZN12MessageQueue8pollOnceEi+0x105>
			74d: R_X86_64_PC32	printf-0x4
	    result = -2;
 751:	c7 85 2c ff ff ff fe 	movl   $0xfffffffe,-0xd4(%rbp)
 758:	ff ff ff 
	    return result;
 75b:	8b 85 2c ff ff ff    	mov    -0xd4(%rbp),%eax
 761:	e9 fc 00 00 00       	jmpq   862 <_ZN12MessageQueue8pollOnceEi+0x216>
        }

        // Check for poll timeout.
        if (eventCount == 0) {
 766:	83 bd 34 ff ff ff 00 	cmpl   $0x0,-0xcc(%rbp)
 76d:	75 2b                	jne    79a <_ZN12MessageQueue8pollOnceEi+0x14e>
            printf("tid:%d MessageQueue::pollOnce eventCount == 0.\n",(unsigned)pthread_self());
 76f:	e8 00 00 00 00       	callq  774 <_ZN12MessageQueue8pollOnceEi+0x128>
			770: R_X86_64_PC32	pthread_self-0x4
 774:	89 c6                	mov    %eax,%esi
 776:	bf 00 00 00 00       	mov    $0x0,%edi
			777: R_X86_64_32	.rodata+0x3f8
 77b:	b8 00 00 00 00       	mov    $0x0,%eax
 780:	e8 00 00 00 00       	callq  785 <_ZN12MessageQueue8pollOnceEi+0x139>
			781: R_X86_64_PC32	printf-0x4
	    result = -3;
 785:	c7 85 2c ff ff ff fd 	movl   $0xfffffffd,-0xd4(%rbp)
 78c:	ff ff ff 
	    return result;
 78f:	8b 85 2c ff ff ff    	mov    -0xd4(%rbp),%eax
 795:	e9 c8 00 00 00       	jmpq   862 <_ZN12MessageQueue8pollOnceEi+0x216>
        }
        for (int i = 0; i < eventCount; i++) {
 79a:	c7 85 30 ff ff ff 00 	movl   $0x0,-0xd0(%rbp)
 7a1:	00 00 00 
 7a4:	e9 a2 00 00 00       	jmpq   84b <_ZN12MessageQueue8pollOnceEi+0x1ff>
            int fd = eventItems[i].data.fd;
 7a9:	8b 85 30 ff ff ff    	mov    -0xd0(%rbp),%eax
 7af:	48 63 d0             	movslq %eax,%rdx
 7b2:	48 89 d0             	mov    %rdx,%rax
 7b5:	48 01 c0             	add    %rax,%rax
 7b8:	48 01 d0             	add    %rdx,%rax
 7bb:	48 c1 e0 02          	shl    $0x2,%rax
 7bf:	48 01 e8             	add    %rbp,%rax
 7c2:	48 2d c0 00 00 00    	sub    $0xc0,%rax
 7c8:	8b 40 04             	mov    0x4(%rax),%eax
 7cb:	89 85 38 ff ff ff    	mov    %eax,-0xc8(%rbp)
            uint32_t epollEvents = eventItems[i].events;
 7d1:	8b 85 30 ff ff ff    	mov    -0xd0(%rbp),%eax
 7d7:	48 63 d0             	movslq %eax,%rdx
 7da:	48 89 d0             	mov    %rdx,%rax
 7dd:	48 01 c0             	add    %rax,%rax
 7e0:	48 01 d0             	add    %rdx,%rax
 7e3:	48 c1 e0 02          	shl    $0x2,%rax
 7e7:	48 01 e8             	add    %rbp,%rax
 7ea:	48 2d c0 00 00 00    	sub    $0xc0,%rax
 7f0:	8b 00                	mov    (%rax),%eax
 7f2:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%rbp)
#ifdef USE_PIPE
            if (fd ==mWakeReadPipeFd){
 7f8:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
 7ff:	8b 40 18             	mov    0x18(%rax),%eax
 802:	3b 85 38 ff ff ff    	cmp    -0xc8(%rbp),%eax
 808:	75 3a                	jne    844 <_ZN12MessageQueue8pollOnceEi+0x1f8>
#else
            if (fd == mWakeEventFd) {
#endif
                if (epollEvents & EPOLLIN) {
 80a:	8b 85 3c ff ff ff    	mov    -0xc4(%rbp),%eax
 810:	83 e0 01             	and    $0x1,%eax
 813:	85 c0                	test   %eax,%eax
 815:	74 11                	je     828 <_ZN12MessageQueue8pollOnceEi+0x1dc>
                    awoken();//当不调用该函数在有event的fd上将数据读出,那么epoll_wait会一直返回.
 817:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
 81e:	48 89 c7             	mov    %rax,%rdi
 821:	e8 00 00 00 00       	callq  826 <_ZN12MessageQueue8pollOnceEi+0x1da>
			822: R_X86_64_PC32	_ZN12MessageQueue6awokenEv-0x4
 826:	eb 1c                	jmp    844 <_ZN12MessageQueue8pollOnceEi+0x1f8>
                } else {
                    printf("tid:%d Ignoring unexpected epoll events 0x%x on wake event fd.\n",(unsigned)pthread_self() ,epollEvents);
 828:	e8 00 00 00 00       	callq  82d <_ZN12MessageQueue8pollOnceEi+0x1e1>
			829: R_X86_64_PC32	pthread_self-0x4
 82d:	8b 95 3c ff ff ff    	mov    -0xc4(%rbp),%edx
 833:	89 c6                	mov    %eax,%esi
 835:	bf 00 00 00 00       	mov    $0x0,%edi
			836: R_X86_64_32	.rodata+0x428
 83a:	b8 00 00 00 00       	mov    $0x0,%eax
 83f:	e8 00 00 00 00       	callq  844 <_ZN12MessageQueue8pollOnceEi+0x1f8>
			840: R_X86_64_PC32	printf-0x4
        if (eventCount == 0) {
            printf("tid:%d MessageQueue::pollOnce eventCount == 0.\n",(unsigned)pthread_self());
	    result = -3;
	    return result;
        }
        for (int i = 0; i < eventCount; i++) {
 844:	83 85 30 ff ff ff 01 	addl   $0x1,-0xd0(%rbp)
 84b:	8b 85 30 ff ff ff    	mov    -0xd0(%rbp),%eax
 851:	3b 85 34 ff ff ff    	cmp    -0xcc(%rbp),%eax
 857:	0f 8c 4c ff ff ff    	jl     7a9 <_ZN12MessageQueue8pollOnceEi+0x15d>
                } else {
                    printf("tid:%d Ignoring unexpected epoll events 0x%x on wake event fd.\n",(unsigned)pthread_self() ,epollEvents);
                }
            }
        }
    }
 85d:	e9 0c fe ff ff       	jmpq   66e <_ZN12MessageQueue8pollOnceEi+0x22>
    return result;
}
 862:	c9                   	leaveq 
 863:	c3                   	retq   

0000000000000864 <_ZN12MessageQueue6awokenEv>:

void MessageQueue::awoken() {
 864:	55                   	push   %rbp
 865:	48 89 e5             	mov    %rsp,%rbp
 868:	48 83 ec 20          	sub    $0x20,%rsp
 86c:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
#ifdef USE_PIPE
    char buffer[1];
    ssize_t nRead;
    //do {
        nRead = read(mWakeReadPipeFd, buffer, sizeof(buffer));
 870:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 874:	8b 40 18             	mov    0x18(%rax),%eax
 877:	48 8d 4d f7          	lea    -0x9(%rbp),%rcx
 87b:	ba 01 00 00 00       	mov    $0x1,%edx
 880:	48 89 ce             	mov    %rcx,%rsi
 883:	89 c7                	mov    %eax,%edi
 885:	e8 00 00 00 00       	callq  88a <_ZN12MessageQueue6awokenEv+0x26>
			886: R_X86_64_PC32	read-0x4
 88a:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    //} while ((nRead == -1 && errno == EINTR) || nRead == sizeof(buffer));
    printf("tid:%d awoken buffer = %s nRead = %zu\n", (unsigned)pthread_self(),buffer,nRead);
 88e:	e8 00 00 00 00       	callq  893 <_ZN12MessageQueue6awokenEv+0x2f>
			88f: R_X86_64_PC32	pthread_self-0x4
 893:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
 897:	48 8d 55 f7          	lea    -0x9(%rbp),%rdx
 89b:	89 c6                	mov    %eax,%esi
 89d:	bf 00 00 00 00       	mov    $0x0,%edi
			89e: R_X86_64_32	.rodata+0x468
 8a2:	b8 00 00 00 00       	mov    $0x0,%eax
 8a7:	e8 00 00 00 00       	callq  8ac <_ZN12MessageQueue6awokenEv+0x48>
			8a8: R_X86_64_PC32	printf-0x4
        //if (errno != EAGAIN) {
            printf("tid:%d Could not read \n",(unsigned)pthread_self());
        //}
    }
#endif
}
 8ac:	c9                   	leaveq 
 8ad:	c3                   	retq   

00000000000008ae <_ZN12MessageQueue4wakeEv>:

void MessageQueue::wake() {
 8ae:	55                   	push   %rbp
 8af:	48 89 e5             	mov    %rsp,%rbp
 8b2:	48 83 ec 20          	sub    $0x20,%rsp
 8b6:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
#ifdef USE_PIPE
    ssize_t nWrite;
    do {
        nWrite = write(mWakeWritePipeFd, "W", 1);
 8ba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
 8be:	8b 40 1c             	mov    0x1c(%rax),%eax
 8c1:	ba 01 00 00 00       	mov    $0x1,%edx
 8c6:	be 00 00 00 00       	mov    $0x0,%esi
			8c7: R_X86_64_32	.rodata+0x48f
 8cb:	89 c7                	mov    %eax,%edi
 8cd:	e8 00 00 00 00       	callq  8d2 <_ZN12MessageQueue4wakeEv+0x24>
			8ce: R_X86_64_PC32	write-0x4
 8d2:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}

void MessageQueue::wake() {
#ifdef USE_PIPE
    ssize_t nWrite;
    do {
 8d6:	48 83 7d f8 ff       	cmpq   $0xffffffffffffffff,-0x8(%rbp)
 8db:	75 0c                	jne    8e9 <_ZN12MessageQueue4wakeEv+0x3b>
        nWrite = write(mWakeWritePipeFd, "W", 1);
    } while (nWrite == -1 && errno == EINTR);
 8dd:	e8 00 00 00 00       	callq  8e2 <_ZN12MessageQueue4wakeEv+0x34>
			8de: R_X86_64_PC32	__errno_location-0x4
 8e2:	8b 00                	mov    (%rax),%eax
 8e4:	83 f8 04             	cmp    $0x4,%eax
 8e7:	74 d1                	je     8ba <_ZN12MessageQueue4wakeEv+0xc>
    printf("tid:%d wake  nWrite = %zu\n", (unsigned)pthread_self(),nWrite);
 8e9:	e8 00 00 00 00       	callq  8ee <_ZN12MessageQueue4wakeEv+0x40>
			8ea: R_X86_64_PC32	pthread_self-0x4
 8ee:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
 8f2:	89 c6                	mov    %eax,%esi
 8f4:	bf 00 00 00 00       	mov    $0x0,%edi
			8f5: R_X86_64_32	.rodata+0x491
 8f9:	b8 00 00 00 00       	mov    $0x0,%eax
 8fe:	e8 00 00 00 00       	callq  903 <_ZN12MessageQueue4wakeEv+0x55>
			8ff: R_X86_64_PC32	printf-0x4
    if (nWrite != 1) {
 903:	48 83 7d f8 01       	cmpq   $0x1,-0x8(%rbp)
 908:	74 16                	je     920 <_ZN12MessageQueue4wakeEv+0x72>
        printf("tid:%d Could not write wake signal\n",(unsigned)pthread_self());
 90a:	e8 00 00 00 00       	callq  90f <_ZN12MessageQueue4wakeEv+0x61>
			90b: R_X86_64_PC32	pthread_self-0x4
 90f:	89 c6                	mov    %eax,%esi
 911:	bf 00 00 00 00       	mov    $0x0,%edi
			912: R_X86_64_32	.rodata+0x4b0
 916:	b8 00 00 00 00       	mov    $0x0,%eax
 91b:	e8 00 00 00 00       	callq  920 <_ZN12MessageQueue4wakeEv+0x72>
			91c: R_X86_64_PC32	printf-0x4
        //if (errno != EAGAIN) {
            printf("tid:%d Could not write wake signal\n",(unsigned)pthread_self());
        //}
    }
#endif
}
 920:	c9                   	leaveq 
 921:	c3                   	retq   

0000000000000922 <_ZN12MessageQueue14enqueueMessageEP7Message>:

void MessageQueue::enqueueMessage(Message* message){
 922:	55                   	push   %rbp
 923:	48 89 e5             	mov    %rsp,%rbp
 926:	48 83 ec 10          	sub    $0x10,%rsp
 92a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
 92e:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
    printf("tid:%d MessageQueue::enqueueMessage! message%p\n",(unsigned)pthread_self(), message);
 932:	e8 00 00 00 00       	callq  937 <_ZN12MessageQueue14enqueueMessageEP7Message+0x15>
			933: R_X86_64_PC32	pthread_self-0x4
 937:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
 93b:	89 c6                	mov    %eax,%esi
 93d:	bf 00 00 00 00       	mov    $0x0,%edi
			93e: R_X86_64_32	.rodata+0x4d8
 942:	b8 00 00 00 00       	mov    $0x0,%eax
 947:	e8 00 00 00 00       	callq  94c <_ZN12MessageQueue14enqueueMessageEP7Message+0x2a>
			948: R_X86_64_PC32	printf-0x4
    queueAtFront(message);
 94c:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
 950:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 954:	48 89 d6             	mov    %rdx,%rsi
 957:	48 89 c7             	mov    %rax,%rdi
 95a:	e8 00 00 00 00       	callq  95f <_ZN12MessageQueue14enqueueMessageEP7Message+0x3d>
			95b: R_X86_64_PC32	_ZN12MessageQueue12queueAtFrontEP7Message-0x4
    wake();
 95f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 963:	48 89 c7             	mov    %rax,%rdi
 966:	e8 00 00 00 00       	callq  96b <_ZN12MessageQueue14enqueueMessageEP7Message+0x49>
			967: R_X86_64_PC32	_ZN12MessageQueue4wakeEv-0x4
}
 96b:	c9                   	leaveq 
 96c:	c3                   	retq   
 96d:	90                   	nop

000000000000096e <_ZN12MessageQueue14getNextMessageEv>:

Message* MessageQueue::getNextMessage(){
 96e:	55                   	push   %rbp
 96f:	48 89 e5             	mov    %rsp,%rbp
 972:	48 83 ec 10          	sub    $0x10,%rsp
 976:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
    pollOnce(-1);
 97a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 97e:	be ff ff ff ff       	mov    $0xffffffff,%esi
 983:	48 89 c7             	mov    %rax,%rdi
 986:	e8 00 00 00 00       	callq  98b <_ZN12MessageQueue14getNextMessageEv+0x1d>
			987: R_X86_64_PC32	_ZN12MessageQueue8pollOnceEi-0x4
    return removeAtTail(); //如果MessageQueue为空被唤醒说明该线程要退出loop
 98b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
 98f:	48 89 c7             	mov    %rax,%rdi
 992:	e8 00 00 00 00       	callq  997 <_ZN12MessageQueue14getNextMessageEv+0x29>
			993: R_X86_64_PC32	_ZN12MessageQueue12removeAtTailEv-0x4
}
 997:	c9                   	leaveq 
 998:	c3                   	retq   

Disassembly of section .text._ZN7MessageC2Ev:

0000000000000000 <_ZN7MessageC1Ev>:
private: 
    //构造函数为私有的方法防止其它对象中创建该实例
    Message(int what) : what(what) {}
public:
    virtual ~Message();
    Message(){mNext = NULL;mTarget = NULL;}
   0:	55                   	push   %rbp
   1:	48 89 e5             	mov    %rsp,%rbp
   4:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
   8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
   c:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
			f: R_X86_64_32S	_ZTV7Message+0x10
  13:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  17:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
  1e:	00 
  1f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
  23:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
  2a:	00 
  2b:	5d                   	pop    %rbp
  2c:	c3                   	retq   
